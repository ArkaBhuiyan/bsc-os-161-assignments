#include <types.h>
#include <lib.h>
#include <synch.h>
#include <test.h>
#include <thread.h>
#include <queue.h>

#include "paintshop.h"



/*
 * **********************************************************************
 * YOU ARE FREE TO CHANGE THIS FILE BELOW THIS POINT AS YOU SEE FIT
 *
 */



/*
 * **********************************************************************
 * FUNCTIONS EXECUTED BY CUSTOMER THREADS
 * **********************************************************************
 */

/*
 * order_paint()
 *
 * Takes one argument specifying the can to be filled. The function
 * makes the can available to staff threads and then blocks until the staff
 * have filled the can with the appropriately tinted paint.
 *
 * The can itself contains an array of requested tints.
 */ 

void order_paint(struct paintcan *can)
{
	P(access_orders);
	q_addtail(orders, can);
	V(access_orders);

	int found = 0;
	while(!found) {
		P(order_ready);
		P(access_done);
		int i;
		for(i = 0; i < NCUSTOMERS; i++) {
			if(can == (struct paintcan *) done_can[i]) {
				done_can[i] = NULL;
				found = 1;
				break;
			}
		}
		V(access_done);
		if(!found) {
			V(order_ready);
			thread_yield();
		}
	}
	/* panic("You need to write some code!!!!"); */
}



/*
 * go_home()
 *
 * This function is called by customers when they go home. It could be
 * used to keep track of the number of remaining customers to allow
 * paint shop staff threads to exit when no customers remain.
 */

void go_home()
{
	remaining_customers--;
}


/*
 * **********************************************************************
 * FUNCTIONS EXECUTED BY PAINT SHOP STAFF THREADS
 * **********************************************************************
 */

/*
 * take_order()
 *
 * This function waits for a new order to be submitted by
 * customers. When submitted, it records the details, and returns a
 * pointer to something representing the order.
 *
 * The return pointer type is void * to allow freedom of representation
 * of orders.
 *
 * The function can return NULL to signal the staff thread it can now
 * exit as their are no customers nor orders left. 
 */
 
void * take_order()
{
	void *ret;

	P(access_orders);
	while(q_empty(orders)) {
		V(access_orders);
		if(remaining_customers == 0) {
			ret = NULL;
			return ret;
		}
		else {
			thread_yield();
			P(access_orders);
		}
	}

	ret = q_remhead(orders);
	V(access_orders);

	return ret;
	/*panic("You need to write some code!!!!");*/
}


/*
 * fill_order()
 *
 * This function takes an order generated by take order and fills the
 * order using the mix() function to tint the paint.
 *
 * NOTE: IT NEEDS TO ENSURE THAT MIX HAS EXCLUSIVE ACCESS TO THE TINTS
 * IT NEEDS TO USE TO FILE THE ORDER.
 */

void fill_order(void *v)
{
	P(access_tints);
	mix(v);
	V(access_tints);
}


/*
 * serve_order()
 *
 * Takes a filled order and makes it available to the waiting customer.
 */

void serve_order(void *v)
{
	int i;
	P(access_done);
	for(i = 0; i < NCUSTOMERS; i++) {
		if(done_can[i] == NULL) {
			done_can[i] = v;
			break;
		}
	}
	V(access_done);
	V(order_ready);
}



/*
 * **********************************************************************
 * INITIALISATION AND CLEANUP FUNCTIONS
 * **********************************************************************
 */


/*
 * paintshop_open()
 *
 * Perform any initialisation you need prior to opening the paint shop to
 * staff and customers
 */

void paintshop_open()
{
	remaining_customers = NCUSTOMERS;
	orders = q_create(NCUSTOMERS);
	access_orders = sem_create("access_orders", 1);
	access_done   = sem_create("access_done", 1);
	order_ready   = sem_create("order_ready", 0);
	access_tints  = sem_create("access_tints", 1);
	int i;
	for(i = 0; i < NCUSTOMERS; i++) {
		done_can[i] = NULL;
	}
}

/*
 * paintshop_close()
 *
 * Perform any cleanup after the paint shop has closed and everybody
 * has gone home.
 */

void paintshop_close()
{
	q_destroy(orders);
	sem_destroy(access_orders);
	sem_destroy(access_done);
	sem_destroy(order_ready);
	sem_destroy(access_tints);
}
